{
  "name": "Shopify_Migration_Assistant_MVP",
  "nodes": [
    {
      "parameters": {
        "binaryPropertyName": "file",
        "options": {
          "delimiter": ",",
          "headerRow": true
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4528,
        512
      ],
      "id": "2ce8d15d-aad2-490f-9bbd-c1478bbe4938",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "// Input: items[] with .json rows from Extract From File\n// Output: single item with headers[], sample[], rows[], AND preserved webhook metadata\n\nconst rows = items.map(i => i.json);\nconst headers = Array.from(new Set(rows.flatMap(r => Object.keys(r))));\nconst sample = rows.slice(0, 50);\n\n// CRITICAL: Preserve webhook metadata from the first item\nconst firstItem = items[0]?.json || {};\n\nconsole.log('=== SAMPLE HEADERS DEBUG ===');\nconsole.log('First item keys:', Object.keys(firstItem));\nconsole.log('overrides_json from first item:', firstItem.overrides_json?.substring?.(0, 100));\nconsole.log('strategy_json from first item:', firstItem.strategy_json);\nconsole.log('strict_mode from first item:', firstItem.strict_mode);\n\n// Build output with both CSV data and webhook metadata\nconst output = {\n  headers,\n  sample,\n  rows,\n  strict_mode: firstItem.strict_mode,\n  strategy_json: firstItem.strategy_json,\n  overrides_json: firstItem.overrides_json,\n  body: firstItem.body,\n  headers_http: firstItem.headers,\n};\n\nconsole.log('Output overrides_json:', output.overrides_json?.substring?.(0, 100));\nconsole.log('=== END DEBUG ===');\n\nreturn [{ json: output }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4320,
        512
      ],
      "id": "80216742-a525-4b3b-ba7a-f9e099fd2721",
      "name": "SampleHeaders"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Headers JSON (string): {{ JSON.stringify($json.headers) }}\n\nCall the tool `mapping_suggester` with the exact string above as its input.\nReturn JSON ONLY with keys: source, mapping, notes.\n",
        "options": {
          "systemMessage": "You are Shopify Migration Mapping Assistant.\n\nYour job:\n\nRead the incoming CSV headers (provided in the user message as a JSON string).\n\nCall the tool mapping_suggester(query: string) first with a JSON string containing the headers:\n{\"headers\":[...original header strings...]}\n\nThe tool returns a JSON string with { source, mapping }.\n\nMerge the tool’s result with your own reasoning if needed.\n\nReturn JSON ONLY (no prose, no code fences), with the exact shape below.\n\nOutput JSON shape (final answer)\n{\n  \"source\": { \"type\": \"woo|big|custom\", \"confidence\": 0.0 },\n  \"mapping\": [\n    { \"source\": \"<exact header as seen>\", \"shopify\": \"<Shopify field>\", \"confidence\": 0.0 }\n  ],\n  \"notes\": []\n}\n\nRules & constraints\n\nCall mapping_suggester first. Pass the headers as a JSON string in query. Do not pass an object.\n\nUse only columns that actually appear in the headers. Do not invent columns.\n\nIf unsure, include fewer pairs and lower confidence—don’t guess wildly.\n\nPrefer these common mappings when present (case-insensitive match on header):\n\nName or Product Name → Title\n\nShort description / Description / Product Description → Body (HTML)\n\nSKU → Variant SKU\n\nRegular price / Price → Variant Price\n\nSale price / Compare at price → Variant Compare At Price\n\nImages / Image URL → Image Src\n\nAttribute 1 name/value(s) → Option1 Name / Option1 Value\nAttribute 2 ... → Option2 ...\nAttribute 3 ... → Option3 ...\n\nDon’t map ambiguous headers like ID, Type, Position unless clearly needed.\n\nConfidence: 0.9 for clear matches (e.g., SKU→Variant SKU), 0.5–0.7 for weaker matches, else omit.\n\nKeep notes as a short array of strings for uncertainties, e.g.\n[\"Could not confirm platform\", \"No obvious mapping for 'Type'\"].\n\nReturn JSON ONLY. No explanations, no markdown, no extra text."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -3104,
        624
      ],
      "id": "fbf80156-e075-4256-be3a-f72b1df2f3a0",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "jsCode": "// Robustly extract model text and parse JSON or salvage from prose\nfunction pick(...vals) {\n  for (const v of vals) if (v !== undefined && v !== null && v !== '') return v;\n  return '';\n}\n\nlet raw = pick(\n  $json.content, $json.message, $json.output, $json.result,\n  $json.text, $json.response, $json.data,\n  $json?.choices?.[0]?.message?.content\n);\n\nif (typeof raw !== 'string') raw = JSON.stringify(raw ?? '');\nraw = raw.trim();\n\n// Strip code fences if present\nif (raw.startsWith('```')) {\n  raw = raw.replace(/^```(?:json)?\\s*/i, '').replace(/```$/, '').trim();\n}\n\nlet parsed;\ntry {\n  parsed = JSON.parse(raw);\n  return [{ json: parsed }];\n} catch (e) {\n  // Try to salvage from prose: `Foo` maps to `Bar`\n  const pairs = [];\n  const re = /`([^`]+)`\\s+maps to\\s+`([^`]+)`/gi;\n  let m;\n  while ((m = re.exec(raw))) {\n    pairs.push({ source: m[1], shopify: m[2], confidence: 0.6 });\n  }\n  if (pairs.length) {\n    return [{\n      json: {\n        source: { type: 'custom', confidence: 0.3 },\n        mapping: pairs,\n        notes: ['Parsed mapping from prose.']\n      }\n    }];\n  }\n  // Last resort: structured error for debugging\n  return [{ json: { error: 'Agent returned non-JSON', raw } }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2752,
        624
      ],
      "id": "db5eb29a-5a3b-4ae3-9709-45608ae982f0",
      "name": "ParseAgentJSON"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Transform & QA — Woo/Custom → Shopify (demo)\n * - Honors per-product overrides: overrides.per_product[handle].chosen_options (≤3) + overflow_to\n * - Demotes overflow to Body(HTML) + Metafields when overflow_to === \"append_to_body_html\"\n * - Supports quick-fixes: strategy.fix_missing_price (\"zero\" | \"copy_compare_at\"), strategy.fix_missing_title {mode:\"prefix\", prefix:\"Untitled\"}\n * - Expands \"simple\" products with pipe-delimited values into cartesian combos for the chosen 3 options\n * - Suppresses EXCESS_OPTION_DIMENSIONS for overridden handles\n * - Emits preview_transformed, files.shopify_csv_base64, qa/gate, decision_log, handles_with_overflow\n */\n\nconst startedAt = new Date();\n\n/* ---------------- helpers ---------------- */\nconst toStr = (v) => (v == null ? \"\" : String(v));\nconst truthy = (v) => v !== null && v !== undefined && v !== \"\";\n\nconst kebab = (s) =>\n  toStr(s)\n    .toLowerCase()\n    .trim()\n    .replace(/&/g, \" and \")\n    .replace(/[^a-z0-9\\s-]/g, \"\")\n    .replace(/\\s+/g, \"-\")\n    .replace(/-+/g, \"-\");\n\nconst csvEscape = (v) => {\n  let s = v == null ? \"\" : String(v);\n  if (/^[=+\\-@]/.test(s)) s = \"'\" + s; // CSV injection hardening\n  if (/[\",\\n]/.test(s)) s = '\"' + s.replace(/\"/g, '\"\"') + '\"';\n  return s;\n};\n\nconst toNumber = (v) => {\n  if (!truthy(v)) return null;\n  const s = String(v).replace(/[^0-9.,-]/g, \"\").replace(\",\", \".\");\n  const n = parseFloat(s);\n  return Number.isFinite(n) ? n : null;\n};\n\nconst firstImage = (v) => {\n  if (!truthy(v)) return \"\";\n  return String(v).split(\",\").map((x) => x.trim()).filter(Boolean)[0] || \"\";\n};\nconst splitImages = (v) =>\n  !truthy(v) ? [] : String(v).split(\",\").map((x) => x.trim()).filter(Boolean);\n\nconst pick = (row, names) => {\n  for (const n of names) {\n    if (truthy(row[n])) return row[n];\n  }\n  return \"\";\n};\n\nconst titleCase = (s) =>\n  toStr(s)\n    .trim()\n    .replace(/\\s+/g, \" \")\n    .replace(/\\b\\w/g, (c) => c.toUpperCase());\n\n/* ---------------- inputs ---------------- */\nconst headers = Array.isArray($json.headers) ? $json.headers : [];\nconst rowsIn = Array.isArray($json.rows) ? $json.rows : [];\nconst mappingArr = Array.isArray($json.mapping) ? $json.mapping : [];\n\nconst strategy =\n  $json.strategy && typeof $json.strategy === \"object\" ? $json.strategy : {};\nconst strict_mode = !!$json.strict_mode;\n\nconst overrides =\n  $json.overrides && typeof $json.overrides === \"object\" ? $json.overrides : {};\nconst perProduct =\n  overrides.per_product && typeof overrides.per_product === \"object\"\n    ? overrides.per_product\n    : {};\n\nlet source = $json.source || { type: \"custom\", confidence: 0.5 };\n\n// policy defaults\nconst policy = Object.assign(\n  { duplicate_handle: \"flag_only\", missing_sku: \"default_auto_suffix\" },\n  $json.policy || {}\n);\n\n/* ---------------- attribute scanners ---------------- */\nfunction scanAttributePairs(allHeaders) {\n  const pairs = [];\n  const nameRe = /^Attribute\\s+(\\d+)\\s+name$/i;\n  const valRe = /^Attribute\\s+(\\d+)\\s+value\\(s\\)$/i;\n\n  const names = {};\n  const vals = {};\n  for (const h of allHeaders) {\n    const m1 = String(h).match(nameRe);\n    const m2 = String(h).match(valRe);\n    if (m1) names[m1[1]] = h;\n    if (m2) vals[m2[1]] = h;\n  }\n  const idxs = new Set([...Object.keys(names), ...Object.keys(vals)]);\n  for (const i of idxs) {\n    pairs.push({ idx: i, nameKey: names[i] || null, valueKey: vals[i] || null });\n  }\n  pairs.sort((a, b) => +a.idx - +b.idx);\n  return pairs;\n}\nconst ATTR_PAIRS = scanAttributePairs(headers);\nconst OPTION_NAME_CANDIDATES = [\n  \"color\",\n  \"size\",\n  \"material\",\n  \"style\",\n  \"length\",\n  \"width\",\n  \"height\",\n  \"flavor\",\n  \"capacity\",\n  \"gender\",\n  \"age\",\n  \"activity\",\n  \"strap\",\n  \"pattern\",\n];\n\nfunction getRowAttributes(row) {\n  const attrs = [];\n  // Woo-style pairs\n  for (const p of ATTR_PAIRS) {\n    const rawName = toStr(row[p.nameKey]).trim();\n    const rawVal = toStr(row[p.valueKey]).trim();\n    if (!rawName && !rawVal) continue;\n    const name = rawName\n      ? titleCase(rawName)\n      : p.nameKey\n      ? titleCase(p.nameKey.replace(/^Attribute\\s+\\d+\\s+name$/i, \"\"))\n      : \"\";\n    if (!name) continue;\n    const vals = rawVal\n      ? rawVal.split(\"|\").map((s) => s.trim()).filter(Boolean)\n      : [];\n    const first = vals[0] || rawVal || \"\";\n    attrs.push({ name, rawName, values: vals, value: first });\n  }\n  // Custom optionish columns\n  const lowerRow = Object.fromEntries(\n    Object.entries(row).map(([k, v]) => [String(k).toLowerCase(), v])\n  );\n  for (const cand of OPTION_NAME_CANDIDATES) {\n    if (lowerRow[cand] != null) {\n      const v = toStr(lowerRow[cand]).trim();\n      if (v) attrs.push({ name: titleCase(cand), rawName: cand, values: [v], value: v });\n    }\n  }\n  return attrs;\n}\n\nfunction analyzeVaryingAttributes(rows) {\n  const map = new Map(); // name -> Set(values)\n  for (const r of rows) {\n    const attrs = getRowAttributes(r);\n    for (const a of attrs) {\n      if (!map.has(a.name)) map.set(a.name, new Set());\n      const vals = (a.values && a.values.length ? a.values : a.value ? [a.value] : []).map(\n        (v) => toStr(v)\n      );\n      if (vals.length) vals.forEach((v) => map.get(a.name).add(v));\n      else map.get(a.name).add(\"\");\n    }\n  }\n  const arr = [...map.entries()].map(([name, set]) => ({\n    name,\n    distinctCount: [...set].filter((v) => v !== \"\").length,\n    values: [...set],\n  }));\n  return arr;\n}\n\nconst PRIORITY_ORDER = [\n  \"Color\",\n  \"Size\",\n  \"Material\",\n  \"Style\",\n  \"Length\",\n  \"Width\",\n  \"Height\",\n  \"Flavor\",\n  \"Capacity\",\n  \"Gender\",\n  \"Age\",\n  \"Activity\",\n  \"Strap\",\n  \"Pattern\",\n];\n\nfunction chooseOptions(varyingArr, limit = 3, forcedPriority = null) {\n  const candidates = varyingArr.filter((a) => a.distinctCount > 1);\n  const priorityIndex = (name) => {\n    const idx = PRIORITY_ORDER.findIndex(\n      (p) => p.toLowerCase() === String(name).toLowerCase()\n    );\n    return idx === -1 ? 999 : idx;\n  };\n  // primary: priority order; secondary: distinctness\n  candidates.sort((a, b) => {\n    const pa = priorityIndex(a.name),\n      pb = priorityIndex(b.name);\n    if (pa !== pb) return pa - pb;\n    if (b.distinctCount !== a.distinctCount) return b.distinctCount - a.distinctCount;\n    return a.name.localeCompare(b.name);\n  });\n\n  let chosen = candidates.slice(0, limit).map((c) => c.name);\n  const overflow = candidates.slice(limit).map((c) => c.name);\n\n  if (Array.isArray(forcedPriority) && forcedPriority.length) {\n    const candNames = new Set(candidates.map((c) => c.name.toLowerCase()));\n    const forced = forcedPriority\n      .map((n) => String(n).trim())\n      .filter((n) => candNames.has(n.toLowerCase()))\n      .slice(0, limit);\n    const rest = candidates\n      .map((c) => c.name)\n      .filter((n) => !forced.map((f) => f.toLowerCase()).includes(n.toLowerCase()));\n    chosen = [...forced, ...rest].slice(0, limit);\n  }\n  return { chosen, overflow, candidates };\n}\n\n/* ---------------- grouping (Woo-aware light) ---------------- */\nfunction groupRowsWooAware(rows) {\n  // Heuristic:\n  // - If Type === 'variation', group by Parent/Name root; else treat as single products\n  const byKey = new Map();\n\n  const typeOf = (r) => toStr(r[\"Type\"] || r[\"type\"]).toLowerCase();\n\n  // First pass: register variable parents\n  for (const r of rows) {\n    const t = typeOf(r);\n    if (t === \"variable\") {\n      const key = toStr(r[\"SKU\"] || r[\"ID\"] || r[\"Name\"]) || kebab(r[\"Name\"] || \"\");\n      if (!byKey.has(key))\n        byKey.set(key, { key, parent: r, variants: [], singles: [], parentImages: [] });\n    }\n  }\n  // Second pass: attach variations\n  for (const r of rows) {\n    const t = typeOf(r);\n    if (t === \"variation\") {\n      const pref = toStr(r[\"Parent\"]);\n      let g = null;\n      if (pref && byKey.has(pref)) g = byKey.get(pref);\n      if (!g) {\n        // fallback: try name root\n        const base = toStr(r[\"Name\"]).replace(/(-[a-z0-9]+){1,3}$/i, \"\").trim().toLowerCase();\n        for (const gr of byKey.values()) {\n          const pn = toStr(gr.parent?.Name || \"\").toLowerCase();\n          if (base && pn && base === pn) {\n            g = gr;\n            break;\n          }\n        }\n      }\n      if (g) g.variants.push(r);\n      else {\n        const key =\n          toStr(r[\"SKU\"] || r[\"ID\"] || r[\"Name\"]) || kebab(r[\"Name\"] || \"\");\n        if (!byKey.has(key))\n          byKey.set(key, { key, parent: null, variants: [], singles: [], parentImages: [] });\n        byKey.get(key).singles.push(r);\n      }\n    }\n  }\n  // Third pass: simples\n  for (const r of rows) {\n    const t = typeOf(r);\n    if (t === \"variable\" || t === \"variation\") continue;\n    const key = toStr(r[\"ID\"] || r[\"SKU\"] || r[\"Name\"]) || kebab(r[\"Name\"] || \"\");\n    if (!byKey.has(key))\n      byKey.set(key, { key, parent: null, variants: [], singles: [], parentImages: [] });\n    byKey.get(key).singles.push(r);\n  }\n  return [...byKey.values()];\n}\n\n/* ---------------- expansion helpers (simple → variants) ---------------- */\nfunction splitPipeValues(v) {\n  if (!truthy(v)) return [];\n  return String(v).split(\"|\").map((s) => s.trim()).filter(Boolean);\n}\nfunction cartesian(arrs) {\n  return arrs.reduce((acc, curr) => {\n    if (!acc.length) return curr.map((x) => [x]);\n    const out = [];\n    for (const a of acc) for (const b of curr) out.push([...a, b]);\n    return out;\n  }, []);\n}\nfunction expandSimpleRowToVariants(r, chosen, skuStrategy = \"keep_parent\") {\n  const attrs = getRowAttributes(r);\n  const byName = Object.fromEntries(attrs.map((a) => [a.name, a]));\n  const perOptValues = chosen.map((n) => {\n    const a = byName[n];\n    if (!a) return [\"\"];\n    const pipe = splitPipeValues(a.values?.length ? a.values.join(\"|\") : a.value);\n    return pipe.length ? pipe : [\"\"];\n  });\n  const combos = cartesian(perOptValues); // [[opt1,opt2,opt3], ...]\n  return combos.map((vals, idx) => {\n    const clone = { ...r };\n\n    // Clear SKU if generating unique (will trigger auto-generation later)\n    if (skuStrategy === \"generate_unique\") {\n      delete clone[\"SKU\"];\n      delete clone[\"Sku\"];\n      delete clone[\"sku\"];\n      delete clone[\"Variant SKU\"];\n    }\n\n    for (let i = 0; i < chosen.length; i++) {\n      clone[`__synthetic_opt_${i + 1}_name`] = chosen[i];\n      clone[`__synthetic_opt_${i + 1}_value`] = vals[i] || \"\";\n    }\n    return clone;\n  });\n}\n\n/* ---------------- overflow → Body & Metafields helpers ---------------- */\nfunction collectOverflowValues(rows, overflowNames) {\n  const map = new Map(); // name -> Set(values)\n  const namesLC = new Set(overflowNames.map((n) => String(n).toLowerCase()));\n  for (const rr of rows) {\n    const attrs = getRowAttributes(rr);\n    for (const a of attrs) {\n      if (!namesLC.has(String(a.name).toLowerCase())) continue;\n      const vals = (a.values && a.values.length ? a.values : a.value ? [a.value] : [])\n        .map((v) => toStr(v).trim())\n        .filter(Boolean);\n      if (!map.has(a.name)) map.set(a.name, new Set());\n      vals.forEach((v) => map.get(a.name).add(v));\n    }\n  }\n  const out = {};\n  for (const [k, set] of map.entries()) out[k] = [...set];\n  return out;\n}\nfunction buildOverflowHtmlLine(overflowMap) {\n  const pairs = Object.entries(overflowMap);\n  if (!pairs.length) return \"\";\n  const chips = pairs.map(([k, arr]) => `${k}: ${arr.join(\" | \")}`);\n  return `\\n<p><em>• ${chips.join(\" • \")}</em></p>`;\n}\n\n/* ---------------- constants & accumulators ---------------- */\nconst SHOPIFY_STD_COLS = [\n  \"Handle\",\n  \"Title\",\n  \"Body (HTML)\",\n  \"Vendor\",\n  \"Tags\",\n  \"Option1 Name\",\n  \"Option1 Value\",\n  \"Option2 Name\",\n  \"Option2 Value\",\n  \"Option3 Name\",\n  \"Option3 Value\",\n  \"Variant SKU\",\n  \"Variant Price\",\n  \"Variant Compare At Price\",\n  \"Variant Inventory Qty\",\n  \"Variant Image\",\n  \"Image Src\",\n  \"Image Position\",\n  \"Metafields\",  // Explicitly include for overflow data\n];\n\nconst REQUIRED_FIELDS = new Set([\"Title\", \"Variant Price\"]);\n\nconst groups = groupRowsWooAware(rowsIn);\n\nconst allOutRows = [];\nconst issues = [];\nconst suggestions = [];\nconst transforms = [];\nlet appliedSlugify = 0,\n  appliedNumericPrice = 0,\n  appliedNumericCompare = 0,\n  appliedVarImg = 0,\n  autoSkuAssigned = 0;\n\nlet decision_overrides_applied = [];\n\n/* ---------------- per-group build ---------------- */\nfor (const g of groups) {\n  const variantRows0 = g.variants.length ? g.variants : g.singles || [];\n  if (!variantRows0.length) continue;\n\n  const parentOrFirst = g.parent || variantRows0[0];\n\n  const rawTitle = pick(parentOrFirst, [\"Name\", \"Product Name\", \"Title\"]);\n  let canonicalTitle = rawTitle || \"(Untitled)\";\n\n  // Handle and base product fields\n  const handle = kebab(canonicalTitle);\n  if (handle) appliedSlugify++;\n\n  // Analyze varying attributes on original set for decisions/UI\n  const varying0 = analyzeVaryingAttributes(variantRows0);\n  const namesAll0 = varying0.filter((a) => a.distinctCount > 1).map((a) => a.name);\n  const namesAll0LC = namesAll0.map((n) => n.toLowerCase());\n  const inNames0 = (n) => namesAll0LC.includes(String(n).toLowerCase());\n\n  // Decide chosen vs overflow (consider overrides)\n  let chosenOptNames = [];\n  let overflowOptNames = [];\n\n  const per = perProduct[handle];\n  if (per && Array.isArray(per.chosen_options) && per.chosen_options.length) {\n    const capLC = per.chosen_options.map((s) => String(s).toLowerCase()).filter(inNames0).slice(0, 3);\n    const priLC = Array.isArray(strategy.option_priority)\n      ? strategy.option_priority.map((x) => String(x).toLowerCase())\n      : [];\n    capLC.sort((a, b) => {\n      const ai = priLC.indexOf(a),\n        bi = priLC.indexOf(b);\n      const sa = ai === -1 ? 999 : ai,\n        sb = bi === -1 ? 999 : bi;\n      if (sa !== sb) return sa - sb;\n      return a.localeCompare(b);\n    });\n    const chosenLC = capLC.slice(0, 3);\n    chosenOptNames = chosenLC.map((x) => namesAll0.find((n) => n.toLowerCase() === x));\n    overflowOptNames = namesAll0.filter(\n      (n) => !chosenOptNames.some((c) => c.toLowerCase() === n.toLowerCase())\n    );\n  } else {\n    const picked = chooseOptions(varying0, 3, strategy.option_priority);\n    chosenOptNames = picked.chosen;\n    overflowOptNames = picked.overflow;\n  }\n\n  // Synthesize variants for \"simple\" with multi-value chosen attrs\n  const parentType = toStr(parentOrFirst[\"Type\"] || parentOrFirst[\"type\"]).toLowerCase();\n  let variantRows = variantRows0;\n  if (parentType === \"simple\" && variantRows0.length === 1 && chosenOptNames.length) {\n    // If any chosen attr has multiple values, expand cartesian\n    const attrs = getRowAttributes(parentOrFirst);\n    const byLC = Object.fromEntries(attrs.map((a) => [String(a.name).toLowerCase(), a]));\n    const multi = chosenOptNames.some((n) => {\n      const a = byLC[String(n).toLowerCase()];\n      const pipeVals = splitPipeValues(a?.values?.length ? a.values.join(\"|\") : a?.value);\n      return pipeVals.length > 1;\n    });\n    if (multi) {\n      const skuStrat = strategy.sku_generation || \"keep_parent\";\n      variantRows = expandSimpleRowToVariants(parentOrFirst, chosenOptNames, skuStrat);\n    }\n  }\n\n  // Product-level fields\n  const productLevel = {\n    Handle: handle,\n    Title: canonicalTitle,\n    \"Body (HTML)\": pick(parentOrFirst, [\n      \"description\",\n      \"Description\",\n      \"Body (HTML)\",\n      \"Short description\",\n    ]),\n    Vendor: pick(parentOrFirst, [\"Vendor\", \"Brand\", \"vendor\"]),\n    Tags: pick(parentOrFirst, [\"Tags\", \"Tag\", \"tags\"]),\n    \"Option1 Name\": chosenOptNames[0] || \"\",\n    \"Option2 Name\": chosenOptNames[1] || \"\",\n    \"Option3 Name\": chosenOptNames[2] || \"\",\n  };\n\n  // Build variant lines\n  const seenCombos = new Set();\n  const suppressDupIssue = overrides?.dedupe_handles === true;\n\n  variantRows.forEach((r, idx) => {\n    const attrs = getRowAttributes(r);\n    const byName = Object.fromEntries(\n      attrs.map((a) => [a.name, (a.values && a.values[0]) ? a.values[0] : (a.value || \"\")])\n    );\n\n    // Prefer synthetic picks for expanded simples\n    const syn1 = r[\"__synthetic_opt_1_value\"] || \"\";\n    const syn2 = r[\"__synthetic_opt_2_value\"] || \"\";\n    const syn3 = r[\"__synthetic_opt_3_value\"] || \"\";\n\n    const ov1 = chosenOptNames[0] ? (syn1 || toStr(byName[chosenOptNames[0]] || \"\")) : \"\";\n    const ov2 = chosenOptNames[1] ? (syn2 || toStr(byName[chosenOptNames[1]] || \"\")) : \"\";\n    const ov3 = chosenOptNames[2] ? (syn3 || toStr(byName[chosenOptNames[2]] || \"\")) : \"\";\n\n    const comboKey = [ov1, ov2, ov3].join(\"||\");\n    if (chosenOptNames.length && seenCombos.has(comboKey)) {\n      if (!suppressDupIssue) {\n        issues.push({ code: \"DUP_VARIANT_COMBO\", field: \"Options\", value: comboKey, handle });\n      }\n      return;\n    }\n    seenCombos.add(comboKey);\n\n    // Prices (with agentic fixes)\n    const reg = toNumber(pick(r, [\"Regular price\", \"Price\", \"price\", \"Variant Price\"]));\n    const sale = toNumber(pick(r, [\"Sale price\", \"Sale Price\", \"Variant Compare At Price\"]));\n    let variantPrice = reg;\n    let variantCompare = null;\n    if (sale && reg && sale < reg) {\n      variantPrice = sale;\n      variantCompare = reg;\n    }\n    // Apply strategy.fix_missing_price\n    const fmp = (strategy && strategy.fix_missing_price) || null;\n    if (variantPrice == null || variantPrice === \"\") {\n      if (fmp === \"zero\" || (typeof fmp === \"object\" && String(fmp.mode).toLowerCase() === \"zero\")) {\n        variantPrice = 0;\n        decision_overrides_applied.push({ type: \"fix_missing_price_zero\", handle });\n      } else if (\n        fmp === \"copy_compare_at\" ||\n        (typeof fmp === \"object\" && String(fmp.mode).toLowerCase() === \"copy_compare_at\")\n      ) {\n        if (variantCompare != null) {\n          variantPrice = variantCompare;\n          decision_overrides_applied.push({ type: \"fix_missing_price_copy_compare_at\", handle });\n        } else {\n          variantPrice = 0;\n          decision_overrides_applied.push({ type: \"fix_missing_price_fallback_zero\", handle });\n        }\n      }\n    }\n\n    if (variantPrice != null) appliedNumericPrice++;\n    if (variantCompare != null) appliedNumericCompare++;\n\n    // SKU\n    let sku = toStr(pick(r, [\"SKU\", \"Sku\", \"sku\", \"Variant SKU\"])).trim();\n    if (!sku) {\n      const n = idx + 1;\n      sku = `${handle}-${String(n).padStart(3, \"0\")}`;\n      autoSkuAssigned++;\n      issues.push({ code: \"AUTO_SKU_ASSIGNED\", field: \"Variant SKU\", value: sku, handle });\n    }\n\n    const rowOut = Object.assign({}, idx === 0 ? productLevel : { Handle: handle }, {\n      \"Option1 Value\": ov1,\n      \"Option2 Value\": ov2,\n      \"Option3 Value\": ov3,\n      \"Variant SKU\": sku || \"\",\n      \"Variant Price\": variantPrice != null ? variantPrice : \"\",\n      \"Variant Compare At Price\": variantCompare != null ? variantCompare : \"\",\n      \"Variant Inventory Qty\":\n        toNumber(pick(r, [\"Stock\", \"stock\", \"Stock Quantity\", \"Inventory\"])) || \"\",\n    });\n\n    // fix_missing_title (first row only)\n    const fmt = (strategy && strategy.fix_missing_title) || null;\n    if (idx === 0 && (!rowOut[\"Title\"] || String(rowOut[\"Title\"]).trim() === \"\")) {\n      if (fmt && typeof fmt === \"object\" && String(fmt.mode).toLowerCase() === \"prefix\") {\n        const pfx = String(fmt.prefix ?? \"Untitled\").trim();\n        rowOut[\"Title\"] = pfx + (canonicalTitle ? ` — ${canonicalTitle}` : \"\");\n        decision_overrides_applied.push({ type: \"fix_missing_title_prefix\", handle, prefix: pfx });\n      }\n    }\n\n    // Variant image\n    const varImg = firstImage(pick(r, [\"Variant Image\", \"Images\", \"Image URL\", \"image\"]));\n    if (varImg) {\n      rowOut[\"Variant Image\"] = varImg;\n      appliedVarImg++;\n    }\n\n    // QA required (blocking)\n    if (!rowOut[\"Title\"] && idx === 0) {\n      issues.push({ code: \"REQ_MISSING_TITLE\", field: \"Title\", handle });\n    }\n    if (rowOut[\"Variant Price\"] === \"\" || rowOut[\"Variant Price\"] === null) {\n      issues.push({\n        code: \"REQ_MISSING_PRICE\",\n        field: \"Variant Price\",\n        handle,\n        sku: rowOut[\"Variant SKU\"],\n      });\n    }\n\n    allOutRows.push(rowOut);\n  });\n\n  // Product images from parent (or first variant) as separate image-only rows\n  const parentImages = splitImages(pick(parentOrFirst, [\"Images\", \"Image URL\", \"image\", \"Image\"]));\n  parentImages.forEach((img, i) => {\n    allOutRows.push({\n      Handle: handle,\n      \"Image Src\": img,\n      \"Image Position\": i + 1,\n    });\n  });\n\n  // Overflow suggestions (for UI) if any\n  const varyingListAll = analyzeVaryingAttributes(variantRows)\n    .filter((a) => a.distinctCount > 1)\n    .map((a) => a.name);\n  const chosenSetLC = new Set((chosenOptNames || []).map((n) => String(n).toLowerCase()));\n  const overflowNow = varyingListAll.filter((n) => !chosenSetLC.has(String(n).toLowerCase()));\n  const hasOverflow = overflowNow.length > 0;\n\n  if (hasOverflow) {\n    suggestions.push({\n      type: \"option_overflow\",\n      message: `Product \"${canonicalTitle}\" has more varying attributes than allowed: ${overflowNow.join(\n        \", \"\n      )}.`,\n      handle,\n      propose: {\n        chosen: chosenOptNames,\n        overflow: overflowNow,\n        store_overflow_as: [\"metafields\", \"append_to_body_html\"],\n      },\n    });\n  }\n\n  // Apply demotion if explicitly requested via per-product override\n  const per2 = perProduct[handle];\n  const overflowAction = per2?.overflow_to;\n\n  if (per2 && Array.isArray(per2.chosen_options) && per2.chosen_options.length) {\n    // Record applied override\n    decision_overrides_applied.push({\n      type: \"cap_options\",\n      handle,\n      chosen: chosenOptNames,\n      overflow: overflowNow,\n    });\n\n    if (hasOverflow && overflowAction === \"append_to_body_html\") {\n      const overflowMap = collectOverflowValues(variantRows, overflowNow);\n      const htmlLine = buildOverflowHtmlLine(overflowMap);\n\n      const pIdx = allOutRows.findIndex((r) => r.Handle === handle && r.Title);\n      if (pIdx !== -1) {\n        const cur = toStr(allOutRows[pIdx][\"Body (HTML)\"] || \"\");\n        allOutRows[pIdx][\"Body (HTML)\"] = cur + htmlLine;\n        const mf = { overflow: overflowMap };\n        allOutRows[pIdx][\"Metafields\"] = JSON.stringify(mf);\n      }\n    }\n  } else {\n    // No override → keep QA issue so UI knows this handle is unresolved\n    if (hasOverflow) {\n      issues.push({\n        code: \"EXCESS_OPTION_DIMENSIONS\",\n        field: \"Options\",\n        handle,\n        attrs: varyingListAll,\n      });\n    }\n  }\n}\n\n/* ---------------- QA roll-up ---------------- */\nconst blockingCodes = new Set([\"REQ_MISSING_TITLE\", \"REQ_MISSING_PRICE\"]);\nconst blocking = issues.filter((i) => blockingCodes.has(i.code)).length;\nconst warnings = issues.length - blocking;\n\n/* ---------------- CSV build ---------------- */\nfunction buildCsv(rows) {\n  if (!rows.length) return \"\";\n  const dyn = Array.from(new Set(rows.flatMap((r) => Object.keys(r)))).filter(\n    (c) => !SHOPIFY_STD_COLS.includes(c)\n  );\n  const cols = [...SHOPIFY_STD_COLS, ...dyn];\n  const header = cols.join(\",\");\n  const body = rows\n    .map((r) => cols.map((c) => csvEscape(r[c])).join(\",\"))\n    .join(\"\\n\");\n  return header + \"\\n\" + body + \"\\n\";\n}\nconst csvStr = buildCsv(allOutRows);\nconst shopifyCsvBase64 = Buffer.from(csvStr, \"utf8\").toString(\"base64\");\n\n/* ---------------- handles_with_overflow (unresolved only) ---------------- */\nconst unresolvedHandles = new Set(\n  issues.filter((i) => i.code === \"EXCESS_OPTION_DIMENSIONS\").map((i) => i.handle)\n);\nconst handles_with_overflow = [];\nfor (const g of groups) {\n  const parentOrFirst = g.parent || g.singles?.[0] || g.variants?.[0];\n  if (!parentOrFirst) continue;\n  const title = pick(parentOrFirst, [\"Name\", \"Product Name\", \"Title\"]) || \"(Untitled)\";\n  const handle = kebab(title);\n  if (!unresolvedHandles.has(handle)) continue;\n  const variantRows = g.variants.length ? g.variants : g.singles || [];\n  const varying = analyzeVaryingAttributes(variantRows);\n  const attrs = varying.filter((a) => a.distinctCount > 1).map((a) => a.name);\n  const picked = chooseOptions(varying, 3, strategy.option_priority);\n  const suggested = picked.chosen.slice(0, 3);\n  handles_with_overflow.push({\n    handle,\n    title,\n    varying_attributes: attrs,\n    suggested_three: suggested,\n  });\n}\n\n/* ---------------- gate ---------------- */\nconst needsOverride = strict_mode\n  ? blocking > 0 // strict blocks only on hard missing Title/Price\n  : blocking > 0 || unresolvedHandles.size > 0;\n\nconst gateReasons = [];\nif (blocking > 0) gateReasons.push(\"Missing required fields (Title or Variant Price).\");\nif (!strict_mode && unresolvedHandles.size > 0)\n  gateReasons.push(\"More than 3 varying attributes — resolve per product.\");\n\n/* ---------------- decision log ---------------- */\nconst completedAt = new Date();\nconst decision_log = {\n  meta: {\n    started_at: startedAt.toISOString(),\n    signature: headers.join(\"|\"),\n    header_count: headers.length,\n    row_count: rowsIn.length,\n    completed_at: completedAt.toISOString(),\n  },\n  transforms: [\n    { rule: \"slugify_handle\", applied_to: appliedSlugify },\n    { rule: \"numeric_parse_price\", applied_to: appliedNumericPrice },\n    { rule: \"numeric_parse_compare_at\", applied_to: appliedNumericCompare },\n    { rule: \"variant_image_first\", applied_to: appliedVarImg },\n  ],\n  qa: { blocking, warnings, issues },\n  gate: { needs_override: needsOverride, reasons: gateReasons },\n  policy,\n  strategy_applied: {\n    strict_mode,\n    option_priority: Array.isArray(strategy.option_priority) ? strategy.option_priority : [],\n    fix_missing_price: strategy.fix_missing_price ?? null,\n    fix_missing_title: strategy.fix_missing_title ?? null,\n  },\n  overrides_applied: {\n    count: decision_overrides_applied.length,\n    list: decision_overrides_applied,\n  },\n};\n\n/* ---------------- final response ---------------- */\nreturn [\n  {\n    json: {\n      source,\n      strategy,\n      strict_mode,\n      preview_transformed: allOutRows.slice(0, 50),\n      files: { shopify_csv_base64: shopifyCsvBase64 },\n      qa: { blocking, warnings, issues },\n      gate: { needs_override: needsOverride, reasons: gateReasons },\n      decision_log,\n      handles_with_overflow,\n    },\n  },\n];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1776,
        512
      ],
      "id": "076db90e-c3ee-4fcc-b7d5-3f12a7c41d77",
      "name": "Transform & QA"
    },
    {
      "parameters": {
        "description": "Given headers on the current item, return { source, mapping[] } for woo|big|custom.",
        "jsCode": "// mapping_suggester: expects query to be a JSON string like {\"headers\":[...]}\ntry {\n  let headers = [];\n  // 1) Parse the tool input string\n  if (typeof query === 'string' && query.trim()) {\n    try {\n      const obj = JSON.parse(query);\n      if (Array.isArray(obj.headers)) headers = obj.headers;\n    } catch {\n      // fallback: comma-separated\n      headers = query.split(',').map(s => s.trim()).filter(Boolean);\n    }\n  }\n  const norm = s => String(s || '').toLowerCase().trim();\n\n  // 2) Heuristic source detection\n  const wooHints = [\"short description\",\"regular price\",\"sale price\",\"attribute 1 name\",\"attribute 1 value(s)\",\"sku\",\"name\",\"images\",\"description\"];\n  const bigHints = [\"product description\",\"price\",\"sale price\",\"option name\",\"option value\",\"sku\",\"product name\",\"image url\"];\n  const H = headers.map(norm);\n  const has = h => H.includes(norm(h));\n  const wooScore = wooHints.filter(has).length;\n  const bigScore = bigHints.filter(has).length;\n  let source = { type: 'custom', confidence: 0.4 };\n  if (wooScore >= bigScore && wooScore > 0) source = { type: 'woo', confidence: wooScore / wooHints.length };\n  if (bigScore > wooScore && bigScore > 0) source = { type: 'big', confidence: bigScore / bigHints.length };\n\n  // 3) Aliases → Shopify\n  const candidates = [\n    { dst: 'Title', srcs: ['name','product name','title'] },\n    { dst: 'Body (HTML)', srcs: ['short description','product short description','description','product description','long description','body'] },\n    { dst: 'Variant SKU', srcs: ['sku','item sku','product sku'] },\n    { dst: 'Variant Price', srcs: ['regular price','price','base price'] },\n    { dst: 'Variant Compare At Price', srcs: ['sale price','compare at price','compare price'] },\n    { dst: 'Image Src', srcs: ['images','image url','image','image urls','picture','pictures'] },\n    { dst: 'Option1 Name', srcs: ['attribute 1 name','option name','option1 name'] },\n    { dst: 'Option1 Value', srcs: ['attribute 1 value(s)','option value','option1 value'] },\n    { dst: 'Option2 Name', srcs: ['attribute 2 name','option2 name'] },\n    { dst: 'Option2 Value', srcs: ['attribute 2 value(s)','option2 value'] },\n    { dst: 'Option3 Name', srcs: ['attribute 3 name','option3 name'] },\n    { dst: 'Option3 Value', srcs: ['attribute 3 value(s)','option3 value'] }\n  ];\n\n  const mapping = [];\n  for (const original of headers) {\n    const n = norm(original);\n    for (const c of candidates) {\n      if (c.srcs.some(s => n === norm(s))) {\n        mapping.push({ source: original, shopify: c.dst, confidence: 0.9 });\n        break;\n      }\n    }\n  }\n\n  // 4) MUST return a STRING (JSON string)\n  return JSON.stringify({ source, mapping });\n} catch (e) {\n  return JSON.stringify({ source: { type: 'custom', confidence: 0 }, mapping: [], error: String(e) });\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -2960,
        832
      ],
      "id": "344303e4-73ad-4e41-8ad9-f8809fb1eca8",
      "name": "mapping_suggester"
    },
    {
      "parameters": {
        "jsCode": "// LoadMappingTemplate (Code)\nconst headers = Array.isArray($json.headers) ? $json.headers : [];\nconst norm = headers.map(h => String(h).trim().toLowerCase()).sort();\nconst signature = norm.join('|');\n\nlet cached_mapping = [];\ntry {\n  if (typeof getWorkflowStaticData === 'function') {\n    const sd = getWorkflowStaticData('global');\n    sd.mappingCache = sd.mappingCache || {};\n    const hit = sd.mappingCache[signature];\n    cached_mapping = Array.isArray(hit) ? hit : [];\n  }\n} catch {}\n\nreturn [{ json: { ...$json, signature, cached_mapping } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3856,
        512
      ],
      "id": "85b442d1-34fc-4a3a-911c-a79a4fa11120",
      "name": "LoadMappingTemplate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4ecac407-26fa-47ad-be68-782c6a0ef3cf",
              "leftValue": "={{ $json.hasCache }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3392,
        512
      ],
      "id": "6531fc1f-2251-4dcd-9a92-26b5b1c5aefe",
      "name": "HasCachedMapping"
    },
    {
      "parameters": {
        "jsCode": "const mapping = $json.cached_mapping || [];\nreturn [{\n  json: {\n    source: { type: 'custom', confidence: 0.95, via: 'cache' },\n    mapping,\n    notes: ['Using cached mapping for this schema signature'],\n    headers: $json.headers,\n    signature: $json.signature\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3040,
        400
      ],
      "id": "df121ec2-bef6-4056-ba42-5c3a91768e8b",
      "name": "UseCachedMapping"
    },
    {
      "parameters": {
        "jsCode": "/**\n * PersistMappingTemplate (Code node safe)\n * Inputs:\n *   - $json.signature: string (from LoadMappingTemplate)\n *   - $json.mapping:   Array<{ source, shopify, confidence? }>  OR\n *   - $json.mapping_template: Array<{ source, proposed, ... }>\n *\n * Behavior:\n *   - Prefer $json.mapping (already normalized).\n *   - Else derive from mapping_template (use `proposed` as the chosen Shopify field).\n *   - Try to persist in workflow static data if available; otherwise skip silently.\n */\n\nconst signature = $json.signature || null;\n\n// Normalize mapping to { source, shopify, confidence }\nlet mapping = [];\nif (Array.isArray($json.mapping) && $json.mapping.length) {\n  mapping = $json.mapping\n    .filter(m => m?.source && m?.shopify)\n    .map(m => ({ source: m.source, shopify: m.shopify, confidence: +m.confidence || 1.0 }));\n} else if (Array.isArray($json.mapping_template) && $json.mapping_template.length) {\n  mapping = $json.mapping_template\n    .filter(m => m?.source && m?.proposed)\n    .map(m => ({ source: m.source, shopify: m.proposed, confidence: 1.0 }));\n}\n\n// Try to persist if possible\nlet persisted = false;\ntry {\n  if (signature && typeof getWorkflowStaticData === 'function') {\n    const sd = getWorkflowStaticData('global');\n    sd.mappingCache = sd.mappingCache || {};\n    sd.mappingCache[signature] = mapping;\n    persisted = true;\n  }\n} catch (e) {\n  // Ignore — static storage not available in this runtime\n}\n\nreturn [{\n  json: {\n    ...$json,\n    persisted,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        96
      ],
      "id": "72bb704f-0f0c-4b2e-b93d-8c891d4b7e24",
      "name": "PersistMappingTemplate"
    },
    {
      "parameters": {
        "jsCode": "// Collect up to 3 inputs safely\nconst inputs =\n  []\n    .concat($input.all(0) || [])\n    .concat($input.all(1) || [])\n    .concat($input.all(2) || [])\n    .map(i => i?.json || {});\n\n// Detect data vs agent payloads\nconst dataSide = inputs.find(x => Array.isArray(x.rows) && Array.isArray(x.headers)) || {};\nconst agentSide = inputs.find(x =>\n  Array.isArray(x.mapping) ||\n  x.mapping_template ||\n  (x.source && x.source.type)\n) || {};\n\n// Optional debug to inspect wiring\nconst _merge_debug = {\n  inputs_seen: inputs.length,\n  saw_rows: !!dataSide.rows,\n  saw_headers: !!dataSide.headers,\n  saw_mapping: !!agentSide.mapping,\n  saw_source: !!(agentSide.source && agentSide.source.type),\n  input_keys: inputs.map(o => Object.keys(o))\n};\n\n// Merge with explicit preservation of webhook metadata from dataSide\n// This ensures overrides_json, strategy_json, and strict_mode from the webhook aren't lost\nreturn [{\n  json: { \n    ...dataSide, \n    ...agentSide, \n    // Explicitly preserve webhook metadata (dataSide takes precedence)\n    strict_mode: dataSide.strict_mode ?? agentSide.strict_mode,\n    strategy_json: dataSide.strategy_json ?? agentSide.strategy_json,\n    overrides_json: dataSide.overrides_json ?? agentSide.overrides_json,\n    body: dataSide.body ?? agentSide.body,\n    headers_http: dataSide.headers_http ?? agentSide.headers_http,\n    _merge_debug \n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2320,
        160
      ],
      "id": "1e1a45fd-a246-4fa6-ab13-393de2c0bc70",
      "name": "Merge: Data + Agent"
    },
    {
      "parameters": {
        "jsCode": "const cm = $json.cached_mapping;\nconst hasCache = Array.isArray(cm) && cm.length > 0;\nreturn [{ json: { ...$json, hasCache } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3600,
        512
      ],
      "id": "66ed3f2d-48b5-4e0e-bb9d-b50d5b7a4760",
      "name": "FlagHasCache"
    },
    {
      "parameters": {
        "jsCode": "const headers = Array.isArray($json.headers) ? $json.headers : [];\nconst rows = Array.isArray($json.rows) ? $json.rows : [];\n\n// Stable signature for caching/analytics\nconst norm = headers.map(h => String(h).trim().toLowerCase()).sort();\nconst signature = norm.join('|');\n\nconst decision_log = {\n  meta: {\n    started_at: new Date().toISOString(),\n    signature,\n    header_count: headers.length,\n    row_count: rows.length,\n  },\n  mapping: { mode: 'unknown', entries: [] },\n  transforms: [],                 // we’ll push applied rules here\n  qa: { blocking: 0, warnings: 0, issues: [] },\n  gate: { needs_override: false, reasons: [] },\n};\n\nreturn [{ json: { ...$json, signature, decision_log } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4112,
        512
      ],
      "id": "14879fcc-7d44-4a9f-9ebd-94a483c26439",
      "name": "LogInit"
    },
    {
      "parameters": {
        "jsCode": "const mapping = Array.isArray($json.mapping) ? $json.mapping : [];\nconst decision_log = $json.decision_log || {};\n\ndecision_log.mapping = {\n  mode: 'cached',\n  entries: mapping.map(m => ({ ...m, origin: 'cache' }))\n};\n\nreturn [{ json: { ...$json, decision_log } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2752,
        352
      ],
      "id": "87bc7ed9-73af-4102-9165-89b855b88a77",
      "name": "Log: MappingPath (cached)"
    },
    {
      "parameters": {
        "jsCode": "const mapping = Array.isArray($json.mapping) ? $json.mapping : [];\nconst source = $json.source || { type: 'unknown', confidence: 0 };\nconst avg = mapping.length\n  ? mapping.reduce((s, m) => s + (+m.confidence || 0), 0) / mapping.length\n  : null;\n\nconst decision_log = $json.decision_log || {};\ndecision_log.mapping = {\n  mode: 'ai',\n  source,\n  avg_confidence: avg,\n  entries: mapping.map(m => ({ ...m, origin: 'ai' }))\n};\n\nreturn [{ json: { ...$json, decision_log } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2528,
        624
      ],
      "id": "f5763a40-7305-4452-a4ea-5ed5c8e993df",
      "name": "Log: MappingPath (ai)"
    },
    {
      "parameters": {
        "jsCode": "// BuildResponse — single JSON reply (Streamlit-ready)\n// - Merges upstream items\n// - Forwards preview_transformed & handles_with_overflow (arrays)\n// - Keeps files.shopify_csv_base64, and also emits a data_url download if present\n\nfunction get(obj, path, dflt = null) {\n  try {\n    return path.split('.').reduce((o, k) => (o && k in o ? o[k] : undefined), obj) ?? dflt;\n  } catch {\n    return dflt;\n  }\n}\n\nconst items = ($input?.all?.() || []).map(i => i.json || {});\nconst fallback = $json || {};\n\n// Prefer the Transform & QA payload (has qa + gate)\nconst tqa = items.find(x => x && x.qa && x.gate) || fallback;\n\n// Optional Assistant summary from any branch\nconst asstItem = items.find(x => x && (x.assistant_summary || (x.assistant && x.assistant.summary))) || {};\nconst assistant_summary =\n  asstItem.assistant_summary ||\n  get(asstItem, 'assistant.summary') ||\n  tqa.assistant_summary ||\n  null;\n\n// Core sections with safe defaults\nconst decision_log = tqa.decision_log || {};\nconst qa   = tqa.qa   || decision_log.qa   || { blocking: 0, warnings: 0, issues: [] };\nconst gate = tqa.gate || decision_log.gate || { needs_override: false, reasons: [] };\n\nconst preview = Array.isArray(tqa.preview_transformed) ? tqa.preview_transformed : [];\nconst handles = Array.isArray(tqa.handles_with_overflow) ? tqa.handles_with_overflow : [];\n\nlet files = tqa.files || {};\nlet base64 = get(files, 'shopify_csv_base64', '');\n\n// If files missing but CSV landed in binary, recover it (n8n binary is already base64)\nif (!base64 && $binary) {\n  const keys = Object.keys($binary);\n  const k = keys.find(x => /csv|shopify/i.test(x)) || keys[0];\n  if (k && $binary[k]?.data) base64 = $binary[k].data;\n  if (base64 && !files) files = {};\n  if (base64) files.shopify_csv_base64 = base64;\n}\n\n// Optional data URL wrapper for convenience\nconst filename = `shopify_products_${new Date().toISOString().slice(0,10)}.csv`;\nconst approxBytes = base64 ? Math.floor(base64.length * 3 / 4) : 0;\nconst download = base64\n  ? { type: 'data_url', filename, bytes: approxBytes, data_url: `data:text/csv;base64,${base64}` }\n  : null;\n\n// Ancillary info\nconst rid = tqa.request_id || get(tqa, 'auth.request_id') || null;\nconst map  = decision_log.mapping || tqa.mapping || {};\nconst src  = tqa.source || { type: 'custom', confidence: 0 };\nconst mapping_mode = map.mode || tqa.mapping_mode || 'unknown';\n\n// Final response (single object)\nconst resp = {\n  ok: true,\n  assistant_summary,\n  qa: {\n    blocking: Number(qa.blocking || 0),\n    warnings: Number(qa.warnings || 0),\n    issues: Array.isArray(qa.issues) ? qa.issues : [],\n  },\n  gate: {\n    needs_override: !!gate.needs_override,\n    reasons: Array.isArray(gate.reasons) ? gate.reasons : [],\n  },\n  preview_transformed: preview,           // <— array of rows (UI table)\n  handles_with_overflow: handles,         // <— per-product cards (UI overrides)\n  files,                                   // <— keep CSV base64 here\n  download,                                // <— convenient data URL\n  mapping_mode,\n  source: src,\n  decision_log,\n  request_id: rid,\n};\n\nreturn [{ json: resp }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        512
      ],
      "id": "3090e50e-3341-419b-adc3-74d16bc39be9",
      "name": "BuildResponse"
    },
    {
      "parameters": {
        "jsCode": "const rid = $json.auth?.request_id || (Date.now().toString());\nconst csv64 = $json.files?.shopify_csv_base64 || '';\nconst filename = `shopify_export_${rid}.csv`;\nreturn [{\n  json: { ok: true },\n  binary: {\n    data: {\n      data: Buffer.from(csv64, 'base64'),\n      mimeType: 'text/csv',\n      fileName: filename,\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        64,
        -128
      ],
      "id": "fda47d84-a4b1-470d-83fa-e5786c60e7a0",
      "name": "MakeCSVBinary"
    },
    {
      "parameters": {
        "jsCode": "// Assistant Summary — produce human-readable summary that references QA & gate\nconst qa = $json.qa || {};\nconst gate = $json.gate || {};\nconst sugg = ($json.suggestions || $json.decision_log?.qa?.suggestions || []).slice(0, 3);\n\nconst lines = [];\nif (gate.needs_override && Array.isArray(gate.reasons) && gate.reasons.length) {\n  lines.push(`Needs review: ${gate.reasons.join('; ')}`);\n}\nif (qa.blocking) lines.push(`Blocking issues: ${qa.blocking}`);\nif (qa.warnings) lines.push(`Warnings: ${qa.warnings}`);\nif (sugg.length) lines.push(`Suggestions: ${sugg.map(s => s.type).join(', ')}`);\n\nreturn [{\n  json: {\n    ...$json, // keep everything from Transform & QA\n    assistant: {\n      ...(($json.assistant || {})),\n      summary: lines.join(' • '),\n      suggestions: sugg\n    }\n  }\n}];\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        512
      ],
      "id": "6565c9eb-95fc-4276-b8a2-9abc260d9f09",
      "name": "AssistantSummary"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json}}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        256,
        512
      ],
      "id": "4e92994c-1a6f-449e-a7fa-677dc29950e6",
      "name": "Respond to Webhook (JSON)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "31e27ac1-6456-466c-b2ca-ee5cc1507bb3",
              "leftValue": "={{ (!$json.strict_mode) || ($json.gate?.needs_override === false) }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -320,
        224
      ],
      "id": "8b13027a-ee38-4639-8fcb-402463ba0f90",
      "name": "CanExport?"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "migrate_v1",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "file",
          "rawBody": false
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -6768,
        528
      ],
      "id": "8cd6e404-a97d-4830-84ce-b684fdcbaba8",
      "name": "Upload Webhook",
      "webhookId": "b9ac2a40-9849-424a-958c-ff6dd9f85d15"
    },
    {
      "parameters": {
        "jsCode": "// Verify HMAC v3 — for n8n \"Code\" node (no 'item' var; use $input)\n// Gate on timestamp+signature (authoritative); log binary info for debugging.\n\nconst SECRET_HARDCODE = 'fb89c7c5fdf29188c03b6ea0e383c5522391e055f32c85ed5091639e6394dee6'; // <-- must match Streamlit\n\nfunction getHeader(h, name){\n  const k = Object.keys(h || {}).find(x => x.toLowerCase() === name.toLowerCase());\n  return k ? String(h[k] ?? '') : '';\n}\n\nfunction hmacHex(secret, s){\n  return require('crypto')\n    .createHmac('sha256', String(secret))\n    .update(Buffer.from(String(s), 'utf8'))\n    .digest('hex');\n}\n\nfunction pickBinary(inItem){\n  const bin = inItem.binary || {};\n  const keys = Object.keys(bin);\n  if (!keys.length) return { has:false, keys:[], chosen: undefined, bytes:0, firstHex:null };\n\n  const prefer = ['file', 'file0', 'data', ...keys];\n  for (const k of prefer){\n    if (!bin[k]) continue;\n    let bytes = 0, firstHex = null;\n    const b64 = bin[k].data;\n    if (typeof b64 === 'string' && b64.length){\n      try{\n        const buf = Buffer.from(b64, 'base64');\n        bytes = buf.length;\n        firstHex = buf.subarray(0,16).toString('hex');\n      }catch(e){}\n    }\n    return { has:true, keys, chosen:k, bytes, firstHex };\n  }\n  return { has:false, keys, chosen: undefined, bytes:0, firstHex:null };\n}\n\n// ----------- read the first incoming item -----------\nconst inItem = $input.first();                 // <— THIS replaces 'item'\nconst orig = inItem.json || {};\nconst headers = orig.headers || {};\nconst ts = getHeader(headers, 'x-timestamp');\nconst rid = getHeader(headers, 'x-request-id');\nconst sig = getHeader(headers, 'x-signature');\nconst headerDigest = (getHeader(headers, 'x-file-digest') || '').toLowerCase();\n\n// ----------- basic checks -----------\nconst secret = SECRET_HARDCODE || String(orig.secret || '');\nif (!secret) {\n  return [{ json: { ...orig, auth_ok:false, reason:'no_server_secret' }, binary: inItem.binary }];\n}\nconst now = Math.floor(Date.now()/1000);\nif (!/^\\d+$/.test(ts) || Math.abs(now - Number(ts)) > 300){\n  return [{ json: { ...orig, auth_ok:false, reason:'stale_timestamp', server_now:now, ts }, binary: inItem.binary }];\n}\nif (!rid || !headerDigest || !sig){\n  return [{ json: { ...orig, auth_ok:false, reason:'missing_auth_headers' }, binary: inItem.binary }];\n}\n\n// ----------- verify signature (authoritative) -----------\nconst base = `${ts}.${rid}.${headerDigest}`;\nconst expected = hmacHex(secret, base);\nconst signature_matches = (sig.toLowerCase() === expected);\n\n// ----------- log binary details (non-blocking) -----------\nconst binInfo = pickBinary(inItem);\n\n// ----------- output -----------\nconst out = {\n  ...orig,\n  auth_ok: signature_matches,\n  reason: signature_matches ? undefined : 'bad_signature',\n  request_id: rid,\n  debug: {\n    ts, server_now: now,\n    header_digest: headerDigest,\n    base_string: base,                 // helpful for debugging\n    expected_signature: expected,      // helpful for debugging\n    provided_signature: sig.toLowerCase(),\n    signature_matches,\n    binary_keys: binInfo.keys,\n    chosen_source: binInfo.chosen,\n    binary_first16_hex: binInfo.firstHex,\n    binary_len: binInfo.bytes\n  }\n};\n\nreturn [{ json: out, binary: inItem.binary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6352,
        528
      ],
      "id": "2fb97259-8334-4c50-a6da-6660b579db39",
      "name": "Verify HMAC"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "34e4b41a-f371-4291-9bbf-27fed549773c",
              "leftValue": "={{ $json.auth_ok }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5680,
        528
      ],
      "id": "bb772e52-bb41-4dc3-89d3-49fa55f1ed2c",
      "name": "Auth OK?"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"ok\": false,\n  \"error\": \"unauthorized\",\n  \"reason\": \"={{$json.reason}}\",\n  \"request_id\": \"={{$json.request_id}}\",\n  \"debug\": \"={{$json.debug}}\"\n}\n",
        "options": {
          "responseCode": 401
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -4736,
        752
      ],
      "id": "3d6a7823-6639-4930-835c-4946d9e3a9bb",
      "name": "401 Unauthorized"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=decision_log:\n{{ JSON.stringify($json.decision_log || {}) }}\n\nqa:\n{{ JSON.stringify($json.qa || {}) }}\n\nmapping_template:\n{{ JSON.stringify($json.mapping_template || []) }}\n",
        "options": {
          "systemMessage": "You are Migration Copilot. Output only a compact JSON object called plan. \nYou receive: decision_log, qa, and mapping_template from a Shopify CSV migration tool.\n\nReturn:\n{\n  \"fix_missing_price\": \"zero\" | \"use_compare_at\" | \"skip\",\n  \"option_priority\": [\"Color\",\"Size\",\"Material\"],      // up to 3 names; must exist in varying attributes if possible\n  \"notes\": [\"short bullets explaining why\"],\n  \"confidence\": 0.0-1.0\n}\n\nRules:\n- Prefer deterministic choices safe for demos.\n- If many rows are missing price and compare-at is available, choose \"use_compare_at\". Otherwise choose \"zero\". Choose \"skip\" only if tiny minority affected.\n- option_priority must prefer attributes with >1 distinct value; prioritize Color > Size > Material > Style > others.\n- Be concise. No prose outside JSON."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1552,
        512
      ],
      "id": "c1aa0a3a-f98e-480b-93e5-17cd453ddb9a",
      "name": "Agent Plan (OpenAI)"
    },
    {
      "parameters": {
        "jsCode": "// Parse Agent Plan (Code) — merge-safe, keeps all upstream fields.\n// Input: item from OpenAI node (or previous node if merged)\n// Output: original JSON + { assistant.plan, strategy }\n\nfunction safeJsonParse(s) {\n  if (!s) return null;\n  if (typeof s === 'object') return s;\n  try { return JSON.parse(String(s)); } catch {}\n  const m = String(s).match(/```(?:json)?\\s*([\\s\\S]*?)```/i);\n  if (m) { try { return JSON.parse(m[1]); } catch {} }\n  return null;\n}\n\nconst j = $json || {};\nconst rawPlan =\n  j.assistant?.plan_text ??\n  j.assistant?.plan ??\n  j.plan ?? j.agent_plan ?? j.content ?? j.result ?? '';\n\nconst parsed = safeJsonParse(rawPlan);\n\nlet assistant = {};\nlet strategy = {};\n\nif (parsed) {\n  assistant = { plan: parsed };\n  strategy = {\n    fix_missing_price: parsed.fix_missing_price ?? null,\n    option_priority: Array.isArray(parsed.option_priority) ? parsed.option_priority : [],\n    notes: Array.isArray(parsed.notes) ? parsed.notes : [],\n    confidence: parsed.confidence ?? null,\n  };\n}\n\nreturn [{ json: { assistant, strategy } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        512
      ],
      "id": "6234525d-6162-446f-b72d-728680eccc6c",
      "name": "Parse Agent Plan"
    },
    {
      "parameters": {
        "jsCode": "// Ensure Binary 'file' → guarantees item.binary.file exists.\n// ALSO PRESERVES webhook form data (strategy_json, overrides_json, strict_mode) in item.json\n\nconst inItem = $input.first();\ninItem.binary = inItem.binary || {};\n\n// Preserve form data fields BEFORE they get lost\nconst body = inItem.json?.body || {};\nconst preservedFields = {\n  strict_mode: body.strict_mode ?? inItem.json?.strict_mode,\n  strategy_json: body.strategy_json ?? inItem.json?.strategy_json,\n  overrides_json: body.overrides_json ?? inItem.json?.overrides_json,\n  headers: inItem.json?.headers, // HTTP headers\n};\n\nconsole.log('=== ENSURE BINARY DEBUG ===');\nconsole.log('Preserving overrides_json:', preservedFields.overrides_json?.substring?.(0, 100));\nconsole.log('Preserving strategy_json:', preservedFields.strategy_json);\nconsole.log('Preserving strict_mode:', preservedFields.strict_mode);\n\nconst keys = Object.keys(inItem.binary);\nif (!keys.length) {\n  inItem.json._no_binary = true;\n  inItem.json._hint = \"Upload Webhook must receive a multipart field named 'file'.\";\n  // Still preserve metadata even if no binary\n  Object.assign(inItem.json, preservedFields);\n  return [inItem];\n}\n\n// Find best source key\nconst preferred = ['file', 'file0', 'data', 'attachment', ...keys];\nconst srcKey = preferred.find(k => inItem.binary[k]);\n\nif (srcKey && srcKey !== 'file') {\n  inItem.binary.file = inItem.binary[srcKey];\n}\n\n// Ensure filename\nif (inItem.binary.file && !inItem.binary.file.fileName) {\n  inItem.binary.file.fileName = inItem.json?.headers?.['x-request-id']\n    ? `upload_${String(inItem.json.headers['x-request-id']).slice(0,8)}.csv`\n    : 'upload.csv';\n}\n\n// CRITICAL: Preserve metadata on the item so it survives Extract from File\nObject.assign(inItem.json, preservedFields);\n\nconsole.log('Item.json after preservation:', Object.keys(inItem.json));\nconsole.log('=== END DEBUG ===');\n\nreturn [inItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4832,
        512
      ],
      "id": "838a1f12-82a0-4493-92cd-e3131e0a65a2",
      "name": "Ensure Binary ‘file’"
    },
    {
      "parameters": {
        "jsCode": "// Soft-merge available inputs (will not wait for both; prefer built-in Merge node if possible)\nlet in0=[], in1=[];\ntry { in0 = $input.all(0); } catch(_) { try { in0 = $input.all(); } catch(__) {} }\ntry { in1 = $input.all(1); } catch(_) {}\n\nconst all = [...(in0||[]), ...(in1||[])];\n\nlet rich = {};\nlet agent = {};\nfor (const it of all) {\n  const j = it?.json || {};\n  const looksRich =\n    (Array.isArray(j.preview_transformed)) ||\n    (j.files && typeof j.files === 'object') ||\n    (Array.isArray(j.mapping_template)) ||\n    (j.decision_log && typeof j.decision_log === 'object');\n  const looksAgent =\n    (j.strategy && typeof j.strategy === 'object') ||\n    (j.assistant && typeof j.assistant === 'object' && 'plan' in j.assistant);\n\n  if (looksRich && !Object.keys(rich).length) rich = j;\n  if (looksAgent && !Object.keys(agent).length) agent = j;\n}\n\nconst out = { ...rich };\nif (agent.assistant) out.assistant = { ...(rich.assistant || {}), ...agent.assistant };\nif (agent.strategy)  out.strategy  = { ...(rich.strategy  || {}), ...agent.strategy  };\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        256
      ],
      "id": "66256f5b-fa4c-48d1-8123-a7b4f7c79cba",
      "name": "MergeData+Agent"
    },
    {
      "parameters": {
        "jsCode": "// Parse Inputs — normalize UI fields onto the item for Transform & QA\n// Outputs guaranteed: strict_mode:boolean, strategy:object, overrides:object\n// NOW READS FROM: URL query params (HIGHEST) > HTTP headers > body > top-level\n\nfunction coerceBool(v) {\n  if (typeof v === 'boolean') return v;\n  if (v === null || v === undefined) return undefined;\n  const s = String(v).trim().toLowerCase();\n  if (s === 'true') return true;\n  if (s === 'false') return false;\n  return undefined;\n}\n\nfunction tryJson(str) {\n  try { return JSON.parse(str); } catch { return undefined; }\n}\n\nfunction stripFence(s) {\n  const re = /```(?:json)?\\s*([\\s\\S]*?)```/i;\n  const m = re.exec(s);\n  return m ? m[1] : s;\n}\n\nfunction stripBOM(s) {\n  return s.replace(/^\\uFEFF/, '');\n}\n\nfunction safeParse(input) {\n  if (!input) return undefined;\n  if (typeof input === 'object') return input;\n\n  let s = String(input);\n  s = stripBOM(s).trim();\n  if (!s) return undefined;\n\n  let parsed = tryJson(s);\n  if (parsed !== undefined) return parsed;\n\n  const de = stripFence(s).trim();\n  if (de && de !== s) {\n    parsed = tryJson(de);\n    if (parsed !== undefined) return parsed;\n  }\n\n  const sq = de || s;\n  if (/['\"]/g.test(sq)) {\n    const swapped = sq.replace(/'/g, '\"');\n    parsed = tryJson(swapped);\n    if (parsed !== undefined) return parsed;\n  }\n\n  return undefined;\n}\n\nfunction isObj(o) {\n  return o && typeof o === 'object' && !Array.isArray(o);\n}\n\nfunction sanitizePerProduct(pp) {\n  if (!isObj(pp)) return undefined;\n  const out = {};\n  for (const [handle, cfg] of Object.entries(pp)) {\n    if (!isObj(cfg)) continue;\n    const chosen = Array.isArray(cfg.chosen_options) ? cfg.chosen_options.filter(Boolean).slice(0, 3) : undefined;\n    const overflow_to = typeof cfg.overflow_to === 'string' ? cfg.overflow_to : undefined;\n    const clean = {};\n    if (chosen && chosen.length) clean.chosen_options = chosen;\n    if (overflow_to) clean.overflow_to = overflow_to;\n    if (Object.keys(clean).length) out[handle] = clean;\n  }\n  return Object.keys(out).length ? out : undefined;\n}\n\n// -------- read first item & merge shapes --------\nconst inItem = $input.first();\nconst src = inItem.json || {};\nconst body = src.body || {};\nconst headers = src.headers || {}; // HTTP headers from webhook\nconst query = src.query || src.params || {}; // URL query params (HIGHEST PRIORITY - survives Extract from File)\n\n// DEBUG: Log what we received\nconsole.log('=== PARSE INPUTS DEBUG ===');\nconsole.log('Query params:', Object.keys(query));\nconsole.log('query.overrides:', query.overrides?.substring?.(0, 100));\nconsole.log('query.strategy:', query.strategy?.substring?.(0, 100));\nconsole.log('Headers received:', Object.keys(headers));\nconsole.log('x-overrides-json header:', headers['x-overrides-json']?.substring?.(0, 100));\nconsole.log('body.overrides_json:', body.overrides_json?.substring?.(0, 100));\nconsole.log('src.overrides_json:', src.overrides_json?.substring?.(0, 100));\n\n// Read from HTTP headers (check both cases since n8n may lowercase)\nconst headersStrict = headers['x-strict-mode'] || headers['X-Strict-Mode'];\nconst headersStrategy = headers['x-strategy-json'] || headers['X-Strategy-Json'];\nconst headersOverrides = headers['x-overrides-json'] || headers['X-Overrides-Json'];\n\n// CRITICAL: Precedence changed - Query params are HIGHEST priority (survive Extract from File)\n// Precedence: Query params > HTTP headers > top-level > body.*\nconst rawStrict = query.strict_mode ?? headersStrict ?? src.strict_mode ?? body.strict_mode;\nconst rawStrategy = query.strategy ?? headersStrategy ?? src.strategy_json ?? body.strategy_json ?? src.strategy;\nconst rawOverrides = query.overrides ?? headersOverrides ?? src.overrides_json ?? body.overrides_json ?? src.overrides;\n\nconsole.log('rawOverrides final (from query first):', typeof rawOverrides, rawOverrides?.substring?.(0, 100));\n\n// Normalize strict_mode\nlet strict_mode = coerceBool(rawStrict);\nif (strict_mode === undefined && typeof rawStrict === 'number') {\n  strict_mode = rawStrict !== 0;\n}\nif (strict_mode === undefined) strict_mode = false;\n\n// Normalize strategy\nconst strategyParsed = safeParse(rawStrategy);\nconst strategy = isObj(strategyParsed) ? strategyParsed : {};\n\n// Normalize overrides\nconst overridesParsed = safeParse(rawOverrides);\nlet overrides = isObj(overridesParsed) ? overridesParsed : {};\nif (isObj(overrides.per_product) || isObj((overridesParsed || {}).per_product)) {\n  const pp = overrides.per_product || (overridesParsed || {}).per_product;\n  const cleanPP = sanitizePerProduct(pp);\n  overrides = Object.assign({}, overrides, cleanPP ? { per_product: cleanPP } : {});\n}\n\nconsole.log('Final overrides:', JSON.stringify(overrides).substring(0, 200));\nconsole.log('=== END DEBUG ===');\n\n// Build output\nconst out = Object.assign({}, src, {\n  strict_mode,\n  strategy,\n  overrides,\n});\n\nreturn [{ json: out, binary: inItem.binary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2032,
        512
      ],
      "id": "49035637-e486-4e8d-8d99-0c3c3c7a70a8",
      "name": "Parse Inputs"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite-preview-06-17",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -3136,
        832
      ],
      "id": "2b7311c2-e597-4157-8b46-4a2bd40fff8e",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "8Qgl14yhOKjISZhK",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite-preview-06-17",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -1552,
        720
      ],
      "id": "6cf9177a-e953-4b39-b1e5-501a051a6480",
      "name": "Google Gemini Chat Model1",
      "credentials": {
        "googlePalmApi": {
          "id": "8Qgl14yhOKjISZhK",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Extract from File": {
      "main": [
        [
          {
            "node": "SampleHeaders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SampleHeaders": {
      "main": [
        [
          {
            "node": "LogInit",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge: Data + Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "ParseAgentJSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseAgentJSON": {
      "main": [
        [
          {
            "node": "Log: MappingPath (ai)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform & QA": {
      "main": [
        [
          {
            "node": "Agent Plan (OpenAI)",
            "type": "main",
            "index": 0
          },
          {
            "node": "MergeData+Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mapping_suggester": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "LoadMappingTemplate": {
      "main": [
        [
          {
            "node": "FlagHasCache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HasCachedMapping": {
      "main": [
        [
          {
            "node": "UseCachedMapping",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge: Data + Agent": {
      "main": [
        [
          {
            "node": "Parse Inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UseCachedMapping": {
      "main": [
        [
          {
            "node": "Log: MappingPath (cached)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FlagHasCache": {
      "main": [
        [
          {
            "node": "HasCachedMapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LogInit": {
      "main": [
        [
          {
            "node": "LoadMappingTemplate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: MappingPath (cached)": {
      "main": [
        [
          {
            "node": "Merge: Data + Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: MappingPath (ai)": {
      "main": [
        [
          {
            "node": "Merge: Data + Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildResponse": {
      "main": [
        [
          {
            "node": "Respond to Webhook (JSON)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MakeCSVBinary": {
      "main": [
        [
          {
            "node": "PersistMappingTemplate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AssistantSummary": {
      "main": [
        [
          {
            "node": "CanExport?",
            "type": "main",
            "index": 0
          },
          {
            "node": "BuildResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CanExport?": {
      "main": [
        [
          {
            "node": "MakeCSVBinary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PersistMappingTemplate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Webhook": {
      "main": [
        [
          {
            "node": "Verify HMAC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify HMAC": {
      "main": [
        [
          {
            "node": "Auth OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auth OK?": {
      "main": [
        [
          {
            "node": "Ensure Binary ‘file’",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "401 Unauthorized",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent Plan (OpenAI)": {
      "main": [
        [
          {
            "node": "Parse Agent Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Agent Plan": {
      "main": [
        [
          {
            "node": "MergeData+Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Binary ‘file’": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MergeData+Agent": {
      "main": [
        [
          {
            "node": "AssistantSummary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Inputs": {
      "main": [
        [
          {
            "node": "Transform & QA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Agent Plan (OpenAI)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "9fec3034-8475-4d17-9135-92f38e0b5712",
  "meta": {
    "instanceId": "ab37de3825d0d429453d353e40497d391dbb157aeeacf4c58b69385a7c859370"
  },
  "id": "dktvfgp6035pqcYf",
  "tags": []
}